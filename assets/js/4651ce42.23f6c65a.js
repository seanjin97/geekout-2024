"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1569],{9467:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var s=a(4848),t=a(8453);const i={sidebar_position:5},r="Database",o={id:"advanced/database",title:"Database",description:"Eh abit useless la api but restart server cannot rmb anything alr. Let's now make our Todo app's data persistent.",source:"@site/docs/advanced/database.md",sourceDirName:"advanced",slug:"/advanced/database",permalink:"/geekout-2024/docs/advanced/database",draft:!1,unlisted:!1,editUrl:"https://github.com/seanjin97/geekout-2024/tree/master/docs/docs/advanced/database.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Security",permalink:"/geekout-2024/docs/advanced/auth"},next:{title:"API Documentation",permalink:"/geekout-2024/docs/advanced/document-it"}},l={},d=[{value:"Relational Databases",id:"relational-databases",level:2},{value:"Non-Relational (NoSQL) Databases",id:"non-relational-nosql-databases",level:2},{value:"Comparison between Relational and Non-Relational Databases",id:"comparison-between-relational-and-non-relational-databases",level:2},{value:"Similarities",id:"similarities",level:3},{value:"Differences",id:"differences",level:3},{value:"Object-Relational Mapping (ORM)",id:"object-relational-mapping-orm",level:2},{value:"Integrating Express.js with a Relational Database (using TypeORM)",id:"integrating-expressjs-with-a-relational-database-using-typeorm",level:2},{value:"ok need to install dependencies",id:"ok-need-to-install-dependencies",level:3},{value:"Configure datasource",id:"configure-datasource",level:3},{value:"But wait, where is our database??",id:"but-wait-where-is-our-database",level:2},{value:"Let&#39;s spin it up using Docker.",id:"lets-spin-it-up-using-docker",level:3},{value:"Breaking it down",id:"breaking-it-down",level:3},{value:"To verify that our database is running:",id:"to-verify-that-our-database-is-running",level:3}];function c(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"database",children:"Database"}),"\n",(0,s.jsx)(n.p,{children:"Eh abit useless la api but restart server cannot rmb anything alr. Let's now make our Todo app's data persistent."}),"\n",(0,s.jsx)(n.p,{children:"When building a REST API server, choosing the right database is crucial to efficiently store and retrieve data. There are two main types of databases: relational and non-relational (NoSQL)."}),"\n",(0,s.jsx)(n.h2,{id:"relational-databases",children:"Relational Databases"}),"\n",(0,s.jsx)(n.p,{children:"Relational databases organize data into tables with predefined schemas, where each table consists of rows (records) and columns (fields). Tables are related to each other using primary and foreign keys. Examples of relational databases include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"PostgreSQL (i luv)"}),"\n",(0,s.jsx)(n.li,{children:"MySQL"}),"\n",(0,s.jsx)(n.li,{children:"Oracle Database"}),"\n",(0,s.jsx)(n.li,{children:"Microsoft SQL Server"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"non-relational-nosql-databases",children:"Non-Relational (NoSQL) Databases"}),"\n",(0,s.jsx)(n.p,{children:"Non-relational databases, also known as NoSQL databases, provide a flexible schema and scale horizontally. They are designed to handle large amounts of unstructured or semi-structured data. Examples of non-relational databases include:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"MongoDB"}),"\n",(0,s.jsx)(n.li,{children:"Cassandra"}),"\n",(0,s.jsx)(n.li,{children:"Redis (more for caching)"}),"\n",(0,s.jsx)(n.li,{children:"Couchbase"}),"\n",(0,s.jsx)(n.li,{children:"Firebase Realtime Database"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"comparison-between-relational-and-non-relational-databases",children:"Comparison between Relational and Non-Relational Databases"}),"\n",(0,s.jsx)(n.h3,{id:"similarities",children:"Similarities"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Both store and retrieve data"}),"\n",(0,s.jsx)(n.li,{children:"Both support CRUD (Create, Read, Update, Delete) operations"}),"\n",(0,s.jsx)(n.li,{children:"Both can be used for various applications"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"differences",children:"Differences"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Relational Databases"}),(0,s.jsx)(n.th,{children:"Non-Relational Databases"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Fixed schema"}),(0,s.jsx)(n.td,{children:"Flexible schema"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Structured data"}),(0,s.jsx)(n.td,{children:"Unstructured or semi-structured data"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"SQL query language"}),(0,s.jsx)(n.td,{children:"NoSQL query languages"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Vertical scaling"}),(0,s.jsx)(n.td,{children:"Horizontal scaling"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"https://www.mongodb.com/resources/basics/databases/acid-transactions",children:"ACID"})," transactions"]}),(0,s.jsx)(n.td,{children:"Eventual consistency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Strong consistency"}),(0,s.jsx)(n.td,{children:"Weak consistency"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Suitable for complex queries"}),(0,s.jsx)(n.td,{children:"Suitable for large-scale, simple queries"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"object-relational-mapping-orm",children:"Object-Relational Mapping (ORM)"}),"\n",(0,s.jsx)(n.p,{children:"When integrating an Express.js server with a relational database, you often need to map the JSON data received from the client to the corresponding schema in the database. This process is known as Object-Relational Mapping (ORM)."}),"\n",(0,s.jsx)(n.h2,{id:"integrating-expressjs-with-a-relational-database-using-typeorm",children:"Integrating Express.js with a Relational Database (using TypeORM)"}),"\n",(0,s.jsxs)(n.p,{children:["Let's use the ",(0,s.jsx)(n.a,{href:"https://typeorm.io/",children:"TypeORM library"})," as the ORM for our app. Why?\n",(0,s.jsx)("small",{children:(0,s.jsx)(n.em,{children:"idk, i just feel like it. it's p robust and popular. The syntax for TypeORM feels quite similar to the way Spring Boot does it. i luv spring boot so let's leave it as that. there's like 1 million other ORMs you can use so feel free to use any of them instead. but for this example, i'll stick to typeORM."})})]}),"\n",(0,s.jsx)(n.p,{children:"TypeORM supports various relational databases and provides a convenient way to define entities and interact with the database."}),"\n",(0,s.jsxs)(n.p,{children:["Let's start by reading the docs @ ",(0,s.jsx)(n.a,{href:"https://typeorm.io/",children:"https://typeorm.io/"})," and specifically ",(0,s.jsx)(n.a,{href:"https://typeorm.io/usage-with-javascript",children:"https://typeorm.io/usage-with-javascript"})]}),"\n",(0,s.jsx)(n.h3,{id:"ok-need-to-install-dependencies",children:"ok need to install dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install typeorm pg\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configure-datasource",children:"Configure datasource"}),"\n",(0,s.jsxs)(n.p,{children:["Let's write this into a new file called ",(0,s.jsx)(n.code,{children:"database.js"})," that contains all configuration related to our database."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const typeorm = require("typeorm");\n\nconst Todo = new typeorm.EntitySchema({\n  name: "Todo",\n  columns: {\n    id: {\n      primary: true,\n      type: "int",\n      generated: true,\n    },\n    description: {\n      type: "varchar",\n    },\n    completed: {\n      type: "boolean",\n      default: false,\n    },\n  },\n});\n\nconst dataSource = new typeorm.DataSource({\n  type: "postgres",\n  host: "localhost",\n  port: 5432,\n  username: "postgres",\n  password: "password",\n  database: "postgres",\n  synchronize: true,\n  logging: true,\n  entities: [Todo],\n});\n\nmodule.exports = { dataSource };\n'})}),"\n",(0,s.jsxs)(n.p,{children:["and in ",(0,s.jsx)(n.code,{children:"app.js"})]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-javascript",children:'const { dataSource } = require("./database");\n\n// ...rest of code\n\ndataSource.initialize().then(() => {\n  app.listen(8000, () => {\n    console.log("Server is running on port 8000");\n  });\n});\n'})}),"\n",(0,s.jsx)(n.h2,{id:"but-wait-where-is-our-database",children:"But wait, where is our database??"}),"\n",(0,s.jsx)(n.h3,{id:"lets-spin-it-up-using-docker",children:"Let's spin it up using Docker."}),"\n",(0,s.jsx)(n.p,{children:"Why? It's just so much more convenient, and if anything goes wrong, just delete the container and re-initialise another."}),"\n",(0,s.jsxs)(n.p,{children:["We'll need the ",(0,s.jsx)(n.a,{href:"https://hub.docker.com/_/postgres",children:"postgreSQL image"})," to run. In our case, let's use the version tag ",(0,s.jsx)(n.code,{children:"16.3-alpine3.20"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker run --name postgres-db -e POSTGRES_PASSWORD=password -d postgres:16.3-alpine3.20\n"})}),"\n",(0,s.jsx)(n.h3,{id:"breaking-it-down",children:"Breaking it down"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"docker run"}),": This command is used to start a new container from a Docker image."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"--name postgres-db"}),': This option sets the name of the container to "postgres-db". You can choose any name you prefer for your PostgreSQL container.']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-e POSTGRES_PASSWORD=password"}),': This option sets an environment variable inside the container. In this case, it sets the POSTGRES_PASSWORD environment variable to "password". This environment variable is used by the PostgreSQL image to set the password for the default "postgres" user. You should replace "password" with a strong and secure password of your choice.']}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"-d"}),": This option runs the container in detached mode. It means that the container will run in the background, and you can continue using the terminal for other tasks."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"postgres:16.3-alpine3.20"}),': This specifies the Docker image to be used for creating the container. In this case, it uses the "postgres" image with the tag "16.3-alpine3.20". This particular image is based on Alpine Linux version 3.20 and includes PostgreSQL version 16.3.']}),"\n",(0,s.jsx)(n.h3,{id:"to-verify-that-our-database-is-running",children:"To verify that our database is running:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"docker ps\n"})}),"\n",(0,s.jsxs)(n.p,{children:["You should see that a container called ",(0,s.jsx)(n.code,{children:"postgres-db"})," is running."]})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,n,a)=>{a.d(n,{R:()=>r,x:()=>o});var s=a(6540);const t={},i=s.createContext(t);function r(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);