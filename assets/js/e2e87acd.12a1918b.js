"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[216],{986:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>c});var t=o(4848),s=o(8453);const i={sidebar_position:1},d="Refactoring",r={id:"advanced/refactoring",title:"Refactoring",description:"Refactoring code is the process of restructuring existing computer code without changing its external behavior. The main goal of code refactoring is to improve the code's internal structure, making it more readable, maintainable, and efficient while preserving its functionality.",source:"@site/docs/advanced/refactoring.md",sourceDirName:"advanced",slug:"/advanced/refactoring",permalink:"/geekout-2024/docs/advanced/refactoring",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/advanced/refactoring.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Advanced",permalink:"/geekout-2024/docs/advanced/"},next:{title:"API Documentation",permalink:"/geekout-2024/docs/advanced/document-it"}},a={},c=[{value:"Why refactor",id:"why-refactor",level:2},{value:"Putting it to practice",id:"putting-it-to-practice",level:2},{value:"1. Consolidating all configuration related code to the top",id:"1-consolidating-all-configuration-related-code-to-the-top",level:3},{value:"2. Extracting out duplicated code into re-usable functions",id:"2-extracting-out-duplicated-code-into-re-usable-functions",level:3},{value:"2.1 Function to read all existing todos",id:"21-function-to-read-all-existing-todos",level:4},{value:"Previously",id:"previously",level:5},{value:"Now",id:"now",level:5},{value:"Previously",id:"previously-1",level:5},{value:"Refactored",id:"refactored",level:5},{value:"2.2 Function to get a specific Todo Task using an <code>id</code>",id:"22-function-to-get-a-specific-todo-task-using-an-id",level:4},{value:"Previously",id:"previously-2",level:5},{value:"Now",id:"now-1",level:5},{value:"Previously",id:"previously-3",level:5},{value:"Refactored",id:"refactored-1",level:5},{value:"2.3 You get the gist",id:"23-you-get-the-gist",level:4},{value:"3. Separating into different files",id:"3-separating-into-different-files",level:3},{value:"Final Code",id:"final-code",level:2},{value:"<code>app.js</code>",id:"appjs",level:3},{value:"<code>utils.js</code>",id:"utilsjs",level:3}];function l(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"refactoring",children:"Refactoring"}),"\n",(0,t.jsx)(n.p,{children:"Refactoring code is the process of restructuring existing computer code without changing its external behavior. The main goal of code refactoring is to improve the code's internal structure, making it more readable, maintainable, and efficient while preserving its functionality."}),"\n",(0,t.jsx)(n.h2,{id:"why-refactor",children:"Why refactor"}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Improving code readability"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Renaming variables, functions, and classes to be more descriptive"}),"\n",(0,t.jsx)(n.li,{children:"Adding comments and documentation to explain complex code segments"}),"\n",(0,t.jsx)(n.li,{children:"Formatting the code consistently (indentation, line breaks, etc.)"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"2",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Eliminating code duplication"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identifying and extracting duplicate code into reusable functions or methods"}),"\n",(0,t.jsx)(n.li,{children:"Applying the DRY (Don't Repeat Yourself) principle"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"3",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Simplifying complex logic"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Breaking down large functions or methods into smaller, more focused ones"}),"\n",(0,t.jsx)(n.li,{children:"Reducing the complexity of conditional statements and loops"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"4",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Improving code organization"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Grouping related code together into modules, classes, or packages"}),"\n",(0,t.jsx)(n.li,{children:"Separating concerns and responsibilities into distinct components"}),"\n"]}),"\n",(0,t.jsxs)(n.ol,{start:"5",children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.strong,{children:"Optimizing performance"})}),"\n"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Identifying and removing unnecessary or inefficient code"}),"\n",(0,t.jsx)(n.li,{children:"Applying performance-enhancing techniques like caching or lazy loading"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"putting-it-to-practice",children:"Putting it to practice"}),"\n",(0,t.jsxs)(n.p,{children:["Ya'll probably realised that there is a lot of duplicated code in ",(0,t.jsx)(n.code,{children:"app.js"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"Generally, if we see something being copy pasted around more than twice, it gives enough reason to extract that out into a reusable function."}),"\n",(0,t.jsx)(n.h3,{id:"1-consolidating-all-configuration-related-code-to-the-top",children:"1. Consolidating all configuration related code to the top"}),"\n",(0,t.jsx)(n.p,{children:"Why? It makes it easier to keep track of what configurations are being used in your application."}),"\n",(0,t.jsxs)(n.p,{children:["e.g. all the ",(0,t.jsx)(n.code,{children:"app.use"})]}),"\n",(0,t.jsxs)(n.p,{children:["The top of your ",(0,t.jsx)(n.code,{children:"app.js"})," should look like this"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const { randomInt } = require("crypto");\nconst express = require("express");\nconst cors = require("cors");\nconst fs = require("fs");\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\n\n// Rest of your code here\n'})}),"\n",(0,t.jsx)(n.h3,{id:"2-extracting-out-duplicated-code-into-re-usable-functions",children:"2. Extracting out duplicated code into re-usable functions"}),"\n",(0,t.jsx)(n.p,{children:"Why? Why repeat yourself many times, extract the logic to a function an re-use that function."}),"\n",(0,t.jsx)(n.p,{children:"That way, whenever that logic changes, you only have to modify this re-usable function once instead of having to dig around the code to change it one by one."}),"\n",(0,t.jsx)(n.h4,{id:"21-function-to-read-all-existing-todos",children:"2.1 Function to read all existing todos"}),"\n",(0,t.jsx)(n.p,{children:"This piece of code is scattered everywhere. Let's make it a re-usable function."}),"\n",(0,t.jsx)(n.h5,{id:"previously",children:"Previously"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'// Read our existing todos\nconst existingTodos = fs.readFileSync("./todos.json", "utf-8");\n\nconst formattedData = JSON.parse(existingTodos);\n'})}),"\n",(0,t.jsx)(n.h5,{id:"now",children:"Now"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'function readExistingTodos() {\n  const existingTodos = fs.readFileSync("./todos.json", "utf-8");\n\n  const formattedTodos = JSON.parse(existingTodos);\n\n  return formattedTodos;\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now replace all the repeated dirty code with the function."}),"\n",(0,t.jsx)(n.p,{children:"For e.g."}),"\n",(0,t.jsx)(n.h5,{id:"previously-1",children:"Previously"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/todos", (req, res) => {\n  const data = fs.readFileSync("./todos.json", "utf-8");\n\n  const formattedData = JSON.parse(data);\n\n  res.status(200).json(formattedData);\n});\n'})}),"\n",(0,t.jsx)(n.h5,{id:"refactored",children:"Refactored"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/todos", (req, res) => {\n  const existingTodos = readExistingTodos();\n\n  res.status(200).json(existingTodos);\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:(0,t.jsx)(n.em,{children:"Now test your app to verify that there's no behaviour change or weird bugs that arose from this refactor."})})}),"\n",(0,t.jsx)(n.p,{children:"We always want to make small changes incrementally and immediately test them. We don't wanna get a big surprise when we only test after making multiple big changes. Ain't nobody got the headspace to deal with that in this economy."}),"\n",(0,t.jsxs)(n.h4,{id:"22-function-to-get-a-specific-todo-task-using-an-id",children:["2.2 Function to get a specific Todo Task using an ",(0,t.jsx)(n.code,{children:"id"})]}),"\n",(0,t.jsx)(n.p,{children:"Same thing. This piece of code is scattered everywhere. Let's make it a re-usable function."}),"\n",(0,t.jsx)(n.h5,{id:"previously-2",children:"Previously"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"const existingTodos = readExistingTodos();\n\n// Check that the todo we want to delete exists\nconst theTodoIwant = existingTodos.find((todo) => todo.id === todoId);\n"})}),"\n",(0,t.jsx)(n.h5,{id:"now-1",children:"Now"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:"function getSpecificTodo(id) {\n  const existingTodos = readExistingTodos();\n  const theTodoIwant = existingTodos.find((todo) => todo.id === todoId);\n\n  return theTodoIwant;\n}\n"})}),"\n",(0,t.jsx)(n.p,{children:"Now replace all the repeated dirty code with the function."}),"\n",(0,t.jsx)(n.p,{children:"For e.g."}),"\n",(0,t.jsx)(n.h5,{id:"previously-3",children:"Previously"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const existingTodos = readExistingTodos();\n\n  const theTodoIwant = existingTodos.find((todo) => todo.id === todoId);\n\n  // rest of the code\n});\n'})}),"\n",(0,t.jsx)(n.h5,{id:"refactored-1",children:"Refactored"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'app.get("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const theTodoIwant = getSpecificTodo(todoId);\n  // rest of the code\n});\n'})}),"\n",(0,t.jsx)(n.p,{children:"Now call the endpoint to verify that it still works and repeat for the other endpoints."}),"\n",(0,t.jsx)(n.h4,{id:"23-you-get-the-gist",children:"2.3 You get the gist"}),"\n",(0,t.jsx)(n.p,{children:"What else can be extracted into a re-usable function? Figure it out i ain't got time for dat."}),"\n",(0,t.jsx)(n.h3,{id:"3-separating-into-different-files",children:"3. Separating into different files"}),"\n",(0,t.jsxs)(n.p,{children:["After extracting out the re-usable functions, you'll probably find that you have a bunch of functions sitting around in ",(0,t.jsx)(n.code,{children:"app.js"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["It's cluttering space up. no nice. Why not separate it into a separate file and import it into ",(0,t.jsx)(n.code,{children:"app.js"})]}),"\n",(0,t.jsxs)(n.p,{children:["Let's create a ",(0,t.jsx)(n.code,{children:"utils.js"})," and dump all those re-usable functions there, don't forget to export the functions and import whatever dependency necessary."]}),"\n",(0,t.jsx)(n.p,{children:"Debug any errors on your own, chatgpt it or sum."}),"\n",(0,t.jsx)(n.h2,{id:"final-code",children:"Final Code"}),"\n",(0,t.jsx)(n.p,{children:"After refactoring, you should end up with something like this"}),"\n",(0,t.jsx)(n.h3,{id:"appjs",children:(0,t.jsx)(n.code,{children:"app.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const { randomInt } = require("crypto");\nconst express = require("express");\nconst cors = require("cors");\nconst { readExistingTodos, getSpecificTodo, saveTodos } = require("./utils");\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\n\napp.get("/hello", (req, res) => {\n  res.send("Hello, World!");\n});\n\napp.get("/todos", (req, res) => {\n  const existingTodos = readExistingTodos();\n\n  res.status(200).json(existingTodos);\n});\n\napp.get("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const theTodoIwant = getSpecificTodo(todoId);\n\n  // What if I can\'t find the todo item? I need to handle it with grace\n  if (!theTodoIwant) {\n    res.status(400).json({ error: "cannot find the todo bro" });\n  }\n\n  res.status(200).json(theTodoIwant);\n});\n\napp.post("/todos", (req, res) => {\n  // Logic to create a new todo item\n  const requestBody = req.body;\n\n  const newTodoItemDescription = requestBody.description;\n\n  // What if there\'s no description field given?\n  if (!newTodoItemDescription) {\n    res.status(400).json({ error: "no description bro" });\n  }\n\n  const existingTodos = readExistingTodos();\n\n  // Create a new todo\n  const newTodoItem = {\n    id: randomInt(0, 999999999),\n    description: newTodoItemDescription,\n    completed: false,\n  };\n\n  // Merge the new todo into the existing todos\n  const updatedListOfTodos = [...existingTodos, newTodoItem];\n\n  saveTodos(updatedListOfTodos);\n\n  res.status(201).json(newTodoItem);\n});\n\napp.put("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n  const requestBody = req.body;\n\n  // What if there\'s no request body\n  if (!requestBody) {\n    res.status(400).json({ error: "no request body" });\n  }\n  const description = requestBody.description;\n  const completed = requestBody.completed;\n\n  const existingTodos = readExistingTodos();\n\n  let updatedTodo;\n  // Loop through all todos and update the one we\'re interested in\n  for (let index = 0; index < existingTodos.length; index++) {\n    const todoTask = existingTodos[index];\n    if (todoTask.id === todoId) {\n      todoTask.description = description;\n      todoTask.completed = completed;\n      updatedTodo = todoTask;\n    }\n  }\n\n  if (!updatedTodo) {\n    res.status(400).json("todo not found");\n  }\n  // Save the updated list of todos\n  saveTodos(existingTodos);\n\n  res.status(200).json(updatedTodo);\n});\n\napp.delete("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const existingTodos = readExistingTodos();\n\n  const theTodoIwant = getSpecificTodo(todoId);\n\n  if (!theTodoIwant) {\n    res.status(400).json({ error: "no such todo" });\n  }\n\n  const updatedListOfTodos = existingTodos.filter((todo) => todo.id !== todoId);\n\n  saveTodos(updatedListOfTodos);\n  res.status(204).json();\n});\n\napp.listen(8000, () => {\n  console.log("Server is running on port 8000");\n});\nconst { randomInt } = require("crypto");\nconst express = require("express");\nconst cors = require("cors");\nconst { readExistingTodos, getSpecificTodo, saveTodos } = require("./utils");\n\nconst app = express();\n\napp.use(cors());\napp.use(express.json());\n\napp.get("/hello", (req, res) => {\n  res.send("Hello, World!");\n});\n\napp.get("/todos", (req, res) => {\n  const existingTodos = readExistingTodos();\n\n  res.status(200).json(existingTodos);\n});\n\napp.get("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const theTodoIwant = getSpecificTodo(todoId);\n\n  // What if I can\'t find the todo item? I need to handle it with grace\n  if (!theTodoIwant) {\n    res.status(400).json({ error: "cannot find the todo bro" });\n  }\n\n  res.status(200).json(theTodoIwant);\n});\n\napp.post("/todos", (req, res) => {\n  // Logic to create a new todo item\n  const requestBody = req.body;\n\n  const newTodoItemDescription = requestBody.description;\n\n  // What if there\'s no description field given?\n  if (!newTodoItemDescription) {\n    res.status(400).json({ error: "no description bro" });\n  }\n\n  const existingTodos = readExistingTodos();\n\n  // Create a new todo\n  const newTodoItem = {\n    id: randomInt(0, 999999999),\n    description: newTodoItemDescription,\n    completed: false,\n  };\n\n  // Merge the new todo into the existing todos\n  const updatedListOfTodos = [...existingTodos, newTodoItem];\n\n  saveTodos(updatedListOfTodos);\n\n  res.status(201).json(newTodoItem);\n});\n\napp.put("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n  const requestBody = req.body;\n\n  // What if there\'s no request body\n  if (!requestBody) {\n    res.status(400).json({ error: "no request body" });\n  }\n  const description = requestBody.description;\n  const completed = requestBody.completed;\n\n  const existingTodos = readExistingTodos();\n\n  let updatedTodo;\n  // Loop through all todos and update the one we\'re interested in\n  for (let index = 0; index < existingTodos.length; index++) {\n    const todoTask = existingTodos[index];\n    if (todoTask.id === todoId) {\n      todoTask.description = description;\n      todoTask.completed = completed;\n      updatedTodo = todoTask;\n    }\n  }\n\n  if (!updatedTodo) {\n    res.status(400).json("todo not found");\n  }\n  // Save the updated list of todos\n  saveTodos(existingTodos);\n\n  res.status(200).json(updatedTodo);\n});\n\napp.delete("/todos/:id", (req, res) => {\n  const todoId = Number(req.params.id);\n\n  const existingTodos = readExistingTodos();\n\n  const theTodoIwant = getSpecificTodo(todoId);\n\n  if (!theTodoIwant) {\n    res.status(400).json({ error: "no such todo" });\n  }\n\n  const updatedListOfTodos = existingTodos.filter((todo) => todo.id !== todoId);\n\n  saveTodos(updatedListOfTodos);\n  res.status(204).json();\n});\n\napp.listen(8000, () => {\n  console.log("Server is running on port 8000");\n});\n'})}),"\n",(0,t.jsx)(n.h3,{id:"utilsjs",children:(0,t.jsx)(n.code,{children:"utils.js"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const fs = require("fs");\n\nfunction readExistingTodos() {\n  const existingTodos = fs.readFileSync("./todos.json", "utf-8");\n\n  const formattedTodos = JSON.parse(existingTodos);\n\n  return formattedTodos;\n}\n\nfunction getSpecificTodo(id) {\n  const existingTodos = readExistingTodos();\n  const theTodoIwant = existingTodos.find((todo) => todo.id === id);\n\n  return theTodoIwant;\n}\n\nfunction saveTodos(todos) {\n  fs.writeFileSync("todos.json", JSON.stringify(todos));\n}\nmodule.exports = { readExistingTodos, getSpecificTodo, saveTodos };\n'})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>d,x:()=>r});var t=o(6540);const s={},i=t.createContext(s);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);